
/* roadfinder2.cc - finding roads using road dictionary;
   file 'dcroadfinderonewire.h' must be generated by 'generate_road_dictionary' */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>

using namespace std;
#include <strstream>

#include "dclib.h"
#include "sgutil.h"

//#define ROADS_SEARCH
#include "dcroadfinderonewire.h"


/*xc5vtx150tff1156-2 (SSP)*/

/* 3.48/5/1/0%/0%/3%/25% - II=1 */

void
RoadSearch22(ap_uint<NBIT_SL5> sl5, ap_uint<NBIT_SL4> sl4, ap_uint<NBIT_SL3> sl3,
		     ap_uint<NBIT_SL2> sl2, ap_uint<NBIT_SL1> sl1, ap_uint<NBIT_SL0> sl0,
			 ap_uint<3> sl_threshold, ap_uint<1> *out)
{
#pragma HLS PIPELINE II=1
  ap_uint<1> res;
  ap_uint<3> sum;
  int i,j;

  res = 0;
  ROADS_SEARCH;
  /*
  {
    int i;
    ap_uint<1> test;
    for(i=0; i<NBIT_SL5; i++) {test = (sl5>>i) & 1;if(test) printf("X");else printf("-");}printf("\n");
    for(i=0; i<NBIT_SL4; i++) {test = (sl4>>i) & 1;if(test) printf("X");else printf("-");}printf("\n");
    for(i=0; i<NBIT_SL3; i++) {test = (sl3>>i) & 1;if(test) printf("X");else printf("-");}printf("\n");
    for(i=0; i<NBIT_SL2; i++) {test = (sl2>>i) & 1;if(test) printf("X");else printf("-");}printf("\n");
    for(i=0; i<NBIT_SL1; i++) {test = (sl1>>i) & 1;if(test) printf("X");else printf("-");}printf("\n");
    for(i=0; i<NBIT_SL0; i++) {test = (sl0>>i) & 1;if(test) printf("X");else printf("-");}printf("\n");

  }
  sum = sl5+sl3(  0,  0)+sl1(  0,  0)+sl4(  0,  0)+sl2(  0,  0)+sl0(  0,  0); if(sum>=sl_threshold) res = 1;
  cout<<"-> sl5,4,3,2,1,0="<<sl5(0,0)<<" "<<sl4(0,0)<<" "<<sl3(0,0)<<" "<<sl2(0,0)<<" "<<sl1(0,0)<<" "<<sl0(0,0)<<endl;
  if(res==1) printf("!!!!!!\n");
  */

  *out = res;

  return;
}



/* 4.49/116/112/0%/0%/26%/34% - II=112 */

void
RoadSearch2(word112_t sl[6], ap_uint<112> *res, ap_uint<3> sl_threshold)
{
#pragma HLS ARRAY_PARTITION variable=sl complete dim=1
#pragma HLS PIPELINE II=112
  int i, iw;

  ap_uint<1> out;
  ap_uint<NBIT_SL5> sl5;
  ap_uint<NBIT_SL4> sl4;
  ap_uint<NBIT_SL3> sl3;
  ap_uint<NBIT_SL2> sl2;
  ap_uint<NBIT_SL1> sl1;
  ap_uint<NBIT_SL0> sl0;

  ap_uint<224> slsl[6];
#pragma HLS ARRAY_PARTITION variable=slsl complete dim=1

  for(i=0; i<6; i++)
  {
	slsl[i](223,         MIN_SL5+112) = 0;
    slsl[i](MIN_SL5+111, MIN_SL5)     = sl[i];
    slsl[i](MIN_SL5-1,   0)           = 0;
    /*Word224Print(i,slsl[i]);*/
  }

  *res = 0;

  for(iw=0; iw<112; iw++)
  {
	sl5 = slsl[5]>>(iw+MIN_SL5);
	sl4 = slsl[4]>>(iw+MIN_SL4);
	sl3 = slsl[3]>>(iw+MIN_SL3);
	sl2 = slsl[2]>>(iw+MIN_SL2);
	sl1 = slsl[1]>>(iw+MIN_SL1);
	sl0 = slsl[0]>>(iw+MIN_SL0);
	/*
    cout<<"["<<iw<<"] sl5="<<sl5(0,0)<<endl;
    cout<<"["<<iw<<"] sl4="<<sl4(0,0)<<endl;
    cout<<"["<<iw<<"] sl3="<<sl3(0,0)<<endl;
    cout<<"["<<iw<<"] sl2="<<sl2(0,0)<<endl;
    cout<<"["<<iw<<"] sl1="<<sl1(0,0)<<endl;
    cout<<"["<<iw<<"] sl0="<<sl0(0,0)<<endl;
	*/
    /*printf("\niw=%d\n",iw);*/
	RoadSearch22(sl5,sl4,sl3,sl2,sl1,sl0,sl_threshold,&out);
    /*cout<<"out="<<out<<endl;*/

	(*res)(iw,iw) = out;
    /*Word112Print(iw,(*res));*/
  }

  return;
}
