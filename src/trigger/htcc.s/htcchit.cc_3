
/* htcchit.c - 

strip_pipe[] - single counters

  input:  

  output: 

*/

	
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>

#include <iostream>
using namespace std;



#include "htcclib.h"


//#define DEBUG


#define MAX(a,b)    (a > b ? a : b)
#define MIN(a,b)    (a < b ? a : b)
#define ABS(x)      ((x) < 0 ? -(x) : (x))

#define NPIPE 3 /* the number of 32ns slices to keep and use in htcchit logic; will be shifted 1 element right on every call */

/*xc7vx550tffg1158-1*/

static ap_uint<6> cl2d[NCLSTR][4] = {
  0, 4, 1, 5,  /* cluster 00 */
  4, 8, 5, 9,  /* cluster 01 */
  8, 12,9, 13, /* cluster 02 */
  12,16,13,17, /* cluster 03 */
  16,20,17,21, /* cluster 04 */
  20,24,21,25, /* cluster 05 */
  24,28,25,29, /* cluster 06 */
  28,32,29,33, /* cluster 07 */
  32,36,33,37, /* cluster 08 */
  36,40,37,41, /* cluster 09 */
  40,44,41,45, /* cluster 10 */
  44,0, 45,1,  /* cluster 11 */

  1, 5, 2, 6,  /* cluster 12 */
  5, 9, 6, 10, /* cluster 13 */
  9, 13,10,14, /* cluster 14 */
  13,17,14,18, /* cluster 15 */
  17,21,18,22, /* cluster 16 */
  21,25,22,26, /* cluster 17 */
  25,29,26,30, /* cluster 18 */
  29,33,30,34, /* cluster 19 */
  33,37,34,38, /* cluster 20 */
  37,41,38,42, /* cluster 21 */
  41,45,42,46, /* cluster 22 */
  45,1, 46,2,  /* cluster 23 */

  2, 6, 3, 7,  /* cluster 24 */
  6, 10,7, 11, /* cluster 25 */
  10,14,11,15, /* cluster 26 */
  14,18,15,19, /* cluster 27 */
  18,22,19,23, /* cluster 28 */
  22,26,23,27, /* cluster 29 */
  26,30,27,31, /* cluster 30 */
  30,34,31,35, /* cluster 31 */
  34,38,35,39, /* cluster 32 */
  38,42,39,43, /* cluster 33 */
  42,46,43,47, /* cluster 34 */
  46,2 ,47,3   /* cluster 35 */
};

/* High Threshold Cherenkov Counter:

   S1    S2    S3    S4    S5    S6
  0  4  8 12 16 20 24 28 32 36 40 44
  1  5  9 13 17 21 25 29 33 37 41 45
  2  6 10 14 18 22 26 30 34 38 42 46
  3  7 11 15 19 23 27 31 35 39 43 47

1. cluster is formed by 2x2 window in any location - NCLSTR=36 total

2. for every cluster multiplicity and energy sum are calculated

3. trigger formed if at least one cluster exceeds multiplicity OR energy thresholds

input:
  threshold - individual channel energy threshold
  mult_threshold - cluster multiplicity threshold
  cluster_threshold - cluster energy threshold
  d[] - input adc values

output:
  mult[] - multiplicity for every cluster
  clusters[] - energy sum for every cluster

return:
  1 - if at least one cluster exceeds multiplicity OR energy threshold
  0 - otherwise

 */


/* 1.96/46/8/0%/0%/(10270)1%/(5734)1% II=8 */

void
htcchit(ap_uint<16> strip_threshold, ap_uint<16> mult_threshold, ap_uint<16> cluster_threshold, nframe_t nframes, HTCCStrip_s s_strip, HTCCHit s_hit[NH_READS])
{
//#pragma HLS INTERFACE ap_stable port=nframes
#pragma HLS PIPELINE II=1

  int it, tdif;
  int i, j, ii, jj;

  static HTCCStrip_s strip_pipe[NPIPE];

  /* to become output */
  ap_uint<1> output[NPER][NCHAN];
#pragma HLS ARRAY_PARTITION variable=output complete dim=1
#pragma HLS ARRAY_PARTITION variable=output complete dim=2
  ap_uint<1> dmask[NPER][NCHAN];
#pragma HLS ARRAY_PARTITION variable=dmask complete dim=1
#pragma HLS ARRAY_PARTITION variable=dmask complete dim=2
  ap_uint<1> cmask[NPER][NCHAN];
#pragma HLS ARRAY_PARTITION variable=cmask complete dim=1
#pragma HLS ARRAY_PARTITION variable=cmask complete dim=2
  ap_uint<1> mask[NPER][NCLSTR];
#pragma HLS ARRAY_PARTITION variable=mask complete dim=1
#pragma HLS ARRAY_PARTITION variable=mask complete dim=2

  ap_uint<NCLSTR> maskEnergy, maskMult;

  ap_uint<3> mult[NPER][NCLSTR];
#pragma HLS ARRAY_PARTITION variable=mult complete dim=1
#pragma HLS ARRAY_PARTITION variable=mult complete dim=2
  ap_uint<16> clusters[NPER][NCLSTR];
#pragma HLS ARRAY_PARTITION variable=clusters complete dim=1
#pragma HLS ARRAY_PARTITION variable=clusters complete dim=2


  if(nframes>NPER) nframes = NPER;

#ifdef DEBUG
  printf("== htcchit start ==\n");
  for(int i=0; i<NSTRIP; i++)
  {
    if(s_strip.en[i]>0) cout<<"htcchit: s_strip.en["<<i<<"]="<<s_strip.en[i]<<", s_strip.tm["<<i<<"]="<<s_strip.tm[i]<<endl;
  }
#endif


  /* shift whole pipe to the right ([1]->[2], [0]->[1]) */
  for(int j=(NPIPE-1); j>0; j--)
  {
    for(int i=0; i<NSTRIP; i++)
    {
	  strip_pipe[j].en[i] = strip_pipe[j-1].en[i];
	  strip_pipe[j].tm[i] = strip_pipe[j-1].tm[i];
	}
  }


  /* get NH_READS timing slices of new data and place in first interval of the pipe */
  for(int i=0; i<NSTRIP; i++)
  {
    strip_pipe[0].en[i] = s_strip.en[i];
    strip_pipe[0].tm[i] = s_strip.tm[i];
  }


#ifdef DEBUG
  for(int j=NPIPE-1; j>=0; j--)
  {
    for(int i=0; i<NSTRIP; i++)
    {
      if(strip_pipe[j].en[i]>0) cout<<"htcchit: strip_pipe["<<j<<"].en["<<i<<"]="<<strip_pipe[j].en[i]<<", strip_pipe["<<j<<"].tm["<<i<<"]="<<strip_pipe[j].tm[i]<<endl;
	}
  }
#endif




#if 0
  /**************/
  /* fill d[][] */

  for(int i=0; i<NSTRIP; i++)
  {
    const int add[NPIPE] = {16, 8, 0}; /* add 16 to interval [0] and 8 to interval [1], to get consequative numbering from 0 to 23 */

    /* consider hits from current interval [1] and from next interval [2] within nframes; previous interval [0] not in use */

    /* check if there is hit in interval [1] */
    if( (strip_pipe[1].en[i]) > 0)
	{
      /* add hit from interval [1] to the sum */
      it = strip_pipe[1].tm[i];
#ifdef DEBUG
      cout<<"=> it="<<it<<", i="<<i<<endl;
#endif
      d[it][i] = strip_pipe[1].en[i];

      /* check if there is hit in interval [2], and if it within 'nframes' from hit in interval [1] */
      if( (strip_pipe[2].en[i]) > 0)
	  {
        tdif = (strip_pipe[1].tm[i]+add[1]) - (strip_pipe[2].tm[i]+add[2]);
#ifdef DEBUG
        cout<<"=> tdif1="<<tdif<<endl;
#endif
        if(tdif < 0) tdif = -tdif;
#ifdef DEBUG
        cout<<"=> tdif2="<<tdif<<endl;
#endif
        if(tdif <= nframes)
	    {
          d[it][i] += strip_pipe[2].en[i];
#ifdef DEBUG
          cout<<"=> accept it="<<it<<", i="<<i<<endl;
#endif
	    }
	  }

	}
    else
	{
      for(it=0; it<NPER; it++) d[it][i] = 0;
    }

  }
#endif













  /* single channels mask */
  for(j=0; j<NPER; j++) for(i=0; i<NCHAN; i++) dmask[j][i] = 0;
  for(i=0; i<NCHAN; i++)
  {
	if( strip_pipe[1].en[i] >= strip_threshold)
	{
      it = strip_pipe[1].tm[i];
      dmask[it][i] = 1;
	}
  }
#ifdef DEBUG
  for(j=0; j<NPER; j++) if(dmask[j]>0) cout<<"htcchit: dmask["<<j<<"]="<<hex<<dmask[j]<<dec<<endl;
#endif





#if 1

  /* clusters energy sums */
  for(j=0; j<NPER; j++) for(i=0; i<NCLSTR; i++) clusters[j][i] = 0;
  for(i=0; i<NCLSTR; i++)
  {
    for(ii=0; ii<4; ii++)
    {
      jj = cl2d[i][ii]; /* channel# participating in this cluster */

      if(strip_pipe[1].en[jj] >= strip_threshold)
  	  {
        it = strip_pipe[1].tm[jj];
        clusters[it][i] += strip_pipe[1].en[jj];
	  }

	}
  }





  /* clusters multiplicity */
  for(j=0; j<NPER; j++) for(i=0; i<NCLSTR; i++) mult[j][i] = 0;
  for(i=0; i<NCLSTR; i++)
  {
    for(ii=0; ii<4; ii++)
    {
      jj = cl2d[i][ii]; /* channel# participating in this cluster */
	  if(strip_pipe[1].en[jj] >= strip_threshold)
	  {
        it = strip_pipe[1].tm[jj];
        mult[it][i] ++;
	  }
	}
  }





  /* trigger solution */
  for(j=0; j<NPER; j++)
  {
    maskEnergy = 0;
    maskMult = 0;
    for(i=0; i<NCLSTR; i++)
    {
      if(clusters[j][i] >= cluster_threshold)
	  {
        maskEnergy |= (1<<i);
#ifdef DEBUG
        printf("htcchit: cluster[%d][%d]: energy=%d\n",j,i,(uint16_t)clusters[j][i]);
#endif
	  }
      if(mult[j][i] >= mult_threshold)
	  {
        maskMult |= (1<<i);
#ifdef DEBUG
        printf("htcchit: cluster[%d][%d]: mult=%d\n",j,i,(uint16_t)mult[j][i]);
#endif
	  }
    }
    for(i=0; i<NCLSTR; i++) mask[j][i] = maskEnergy[i] & maskMult[i];
#ifdef DEBUG
    cout<<"htcchit: maskEnergy="<<hex<<maskEnergy<<dec<<endl;
    cout<<"htcchit:   maskMult="<<hex<<maskMult<<dec<<endl;
    cout<<"htcchit:   mask["<<j<<"]="<<hex<<mask[j]<<dec<<endl;
#endif
  }




  for(j=0; j<NPER; j++)
  {
    for(i=0; i<NCHAN; i++) cmask[j][i] = 0;
#ifdef DEBUG
    cout<<"htcchit: CMASK["<<j<<"] BEFOR="<<hex<<cmask[j]<<dec<<endl;
#endif
    for(int i=0; i<NCLSTR; i++)
    {
      if( mask[j][i]==1 )
	  {
        for(int ii=0; ii<4; ii++)
	    {
          cmask[ii][ cl2d[i][ii] ] = 1;
#ifdef DEBUG
          cout<<"FOUND CLUSTER "<<i<<" -> ADD BIT " << cl2d[i][ii] <<" to CMASK" << endl;
#endif
	    }
	  }
    }
#ifdef DEBUG
    cout<<"htcchit: CMASK["<<j<<"] AFTER="<<hex<<cmask[j]<<dec<<endl;
#endif

    for(i=0; i<NCHAN; i++) output[j][i] = dmask[j][i] & cmask[j][i];
  }



#endif /* if 0 */





  /* output stream - NPER writes */
  for(int jj=0; jj<NPER; jj++)
  {
#ifdef DEBUG
    cout<<endl;
    cout<<"htcchit:  dmask["<<jj<<"]="<<hex<<dmask[jj]<<dec<<endl;
    cout<<"htcchit:  cmask["<<jj<<"]="<<hex<<cmask[jj]<<dec<<endl;
    cout<<"htcchit: output["<<jj<<"]="<<hex<<output[jj]<<dec<<endl<<endl;
#endif

    for(ii=0; ii<NCHAN; ii++) s_hit[jj].output[ii] = /*output[jj][ii]*/dmask[jj][ii];
  }


}
