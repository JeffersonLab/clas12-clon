
/* htcchit.c - 

strip_pipe[] - single counters

  input:  

  output: 

*/

	
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>

#include <iostream>
using namespace std;



#include "htcclib.h"



#define DEBUG


#define MAX(a,b)    (a > b ? a : b)
#define MIN(a,b)    (a < b ? a : b)
#define ABS(x)      ((x) < 0 ? -(x) : (x))

#define NPIPE 3 /* the number of 32ns slices to keep and use in htcchit logic; will be shifted 1 element right on every call */

/*xc7vx550tffg1158-1*/

static ap_uint<6> cl2d[NCLSTR][4] = {
  0, 4, 1, 5,  /* cluster 00 */
  4, 8, 5, 9,  /* cluster 01 */
  8, 12,9, 13, /* cluster 02 */
  12,16,13,17, /* cluster 03 */
  16,20,17,21, /* cluster 04 */
  20,24,21,25, /* cluster 05 */
  24,28,25,29, /* cluster 06 */
  28,32,29,33, /* cluster 07 */
  32,36,33,37, /* cluster 08 */
  36,40,37,41, /* cluster 09 */
  40,44,41,45, /* cluster 10 */
  44,0, 45,1,  /* cluster 11 */

  1, 5, 2, 6,  /* cluster 12 */
  5, 9, 6, 10, /* cluster 13 */
  9, 13,10,14, /* cluster 14 */
  13,17,14,18, /* cluster 15 */
  17,21,18,22, /* cluster 16 */
  21,25,22,26, /* cluster 17 */
  25,29,26,30, /* cluster 18 */
  29,33,30,34, /* cluster 19 */
  33,37,34,38, /* cluster 20 */
  37,41,38,42, /* cluster 21 */
  41,45,42,46, /* cluster 22 */
  45,1, 46,2,  /* cluster 23 */

  2, 6, 3, 7,  /* cluster 24 */
  6, 10,7, 11, /* cluster 25 */
  10,14,11,15, /* cluster 26 */
  14,18,15,19, /* cluster 27 */
  18,22,19,23, /* cluster 28 */
  22,26,23,27, /* cluster 29 */
  26,30,27,31, /* cluster 30 */
  30,34,31,35, /* cluster 31 */
  34,38,35,39, /* cluster 32 */
  38,42,39,43, /* cluster 33 */
  42,46,43,47, /* cluster 34 */
  46,2 ,47,3   /* cluster 35 */
};

/* High Threshold Cherenkov Counter:

   S1    S2    S3    S4    S5    S6
  0  4  8 12 16 20 24 28 32 36 40 44
  1  5  9 13 17 21 25 29 33 37 41 45
  2  6 10 14 18 22 26 30 34 38 42 46
  3  7 11 15 19 23 27 31 35 39 43 47

1. cluster is formed by 2x2 window in any location - NCLSTR=36 total

2. for every cluster multiplicity and energy sum are calculated

3. trigger formed if at least one cluster exceeds multiplicity OR energy thresholds

input:
  threshold - individual channel energy threshold
  mult_threshold - cluster multiplicity threshold
  cluster_threshold - cluster energy threshold
  d[] - input adc values

output:
  mult[] - multiplicity for every cluster
  clusters[] - energy sum for every cluster

return:
  1 - if at least one cluster exceeds multiplicity OR energy threshold
  0 - otherwise

 */


/* 1.96/46/8/0%/0%/(10270)1%/(5734)1% II=8 */

void
htcchit(ap_uint<16> strip_threshold, ap_uint<16> mult_threshold, ap_uint<16> cluster_threshold, nframe_t nframes, HTCCStrip_s s_strip, HTCCHit s_hit[NH_READS])
{
//#pragma HLS INTERFACE ap_stable port=nframes
#pragma HLS PIPELINE II=1

  int it, tdif;

  static HTCCStrip_s strip_pipe[NPIPE];

  /* to become output */
  ap_uint<NCHAN> output;
  ap_uint<NCHAN> dmask;
  ap_uint<NCHAN> cmask;

  int i, ii;
  ap_uint<NCLSTR> maskEnergy, maskMult, mask;

  ap_uint<13> d[NPER][NCHAN];
#pragma HLS ARRAY_PARTITION variable=d complete dim=1
#pragma HLS ARRAY_PARTITION variable=d complete dim=2
  ap_uint<3> mult[NCLSTR];
#pragma HLS ARRAY_PARTITION variable=mult complete dim=1
  ap_uint<16> clusters[NCLSTR];
#pragma HLS ARRAY_PARTITION variable=clusters complete dim=1


  if(nframes>NPER) nframes = NPER;

#ifdef DEBUG
  printf("== htcchit start ==\n");
  for(int i=0; i<NSTRIP; i++)
  {
    if(s_strip.en[i]>0) cout<<"htcchit: s_strip.en["<<i<<"]="<<s_strip.en[i]<<", s_strip.tm["<<i<<"]="<<s_strip.tm[i]<<endl;
  }
#endif


  /* shift whole pipe to the right ([1]->[2], [0]->[1]) */
  for(int j=(NPIPE-1); j>0; j--)
  {
    for(int i=0; i<NSTRIP; i++)
    {
	  strip_pipe[j].en[i] = strip_pipe[j-1].en[i];
	  strip_pipe[j].tm[i] = strip_pipe[j-1].tm[i];
	}
  }


  /* get NH_READS timing slices of new data and place in first interval of the pipe */
  for(int i=0; i<NSTRIP; i++)
  {
    strip_pipe[0].en[i] = s_strip.en[i];
    strip_pipe[0].tm[i] = s_strip.tm[i];
  }


#ifdef DEBUG
  for(int j=NPIPE-1; j>=0; j--)
  {
    for(int i=0; i<NSTRIP; i++)
    {
      if(strip_pipe[j].en[i]>0) cout<<"htcchit: strip_pipe["<<j<<"].en["<<i<<"]="<<strip_pipe[j].en[i]<<", strip_pipe["<<j<<"].tm["<<i<<"]="<<strip_pipe[j].tm[i]<<endl;
	}
  }
#endif





  /**************/
  /* fill d[][] */

  for(int i=0; i<NSTRIP; i++)
  {
    const int add[NPIPE] = {16, 8, 0}; /* add 16 to interval [0] and 8 to interval [1], to get consequative numbering from 0 to 23 */

    /* consider hits from current interval [1] and from next interval [2] within nframes; previous interval [0] not in use */

    /* check if there is hit in interval [1] */
    if( (strip_pipe[1].en[i]) > 0)
	{
      /* add hit from interval [1] to the sum */
      it = strip_pipe[1].tm[i];
#ifdef DEBUG
      cout<<"=> it="<<it<<", i="<<i<<endl;
#endif
      d[it][i] = strip_pipe[1].en[i];

      /* check if there is hit in interval [2], and if it within 'nframes' from hit in interval [1] */
      if( (strip_pipe[2].en[i]) > 0)
	  {
        tdif = (strip_pipe[1].tm[i]+add[1]) - (strip_pipe[2].tm[i]+add[2]);
#ifdef DEBUG
        cout<<"=> tdif1="<<tdif<<endl;
#endif
        if(tdif < 0) tdif = -tdif;
#ifdef DEBUG
        cout<<"=> tdif2="<<tdif<<endl;
#endif
        if(tdif <= nframes)
	    {
          d[it][i] += strip_pipe[2].en[i];
#ifdef DEBUG
          cout<<"=> accept it="<<it<<", i="<<i<<endl;
#endif
	    }
	  }

	}
    else
	{
      for(it=0; it<NPER; it++) d[it][i] = 0;
    }

  }



  /****************************************/
  /* go through NH_READS(=NPER) intervals */

  for(int jj=0; jj<NH_READS; jj++)
  {

    /* channel mask */
    dmask = 0;
    for(i=0; i<NCHAN; i++)
    {
	  if(d[jj][i] >= strip_threshold)
	  {
        dmask(i,i) = 1;
#ifdef DEBUG
        printf("htcchit: d[%d][%d] = %d\n",jj,i,(uint16_t)d[jj][i]);
#endif
	  }
    }
#ifdef DEBUG
    if(dmask>0) cout<<"htcchit: dmask="<<hex<<dmask<<dec<<endl;
#endif





#ifdef SINGLES

    output = dmask;

#else

    /* clusters energy sums */

    for(i=0; i<NCLSTR; i++) clusters[i] = 0;
    for(i=0; i<NCLSTR; i++)
    {
      for(ii=0; ii<4; ii++)
	  {
        clusters[i] += d[jj][cl2d[i][ii]];
	  }
    }


    /* clusters multiplicity */

    for(i=0; i<NCLSTR; i++) mult[i] = 0;
    for(i=0; i<NCLSTR; i++)
    {
      for(ii=0; ii<4; ii++)
	  {
	    if(d[jj][cl2d[i][ii]] >= strip_threshold) mult[i] ++;
	  }
    }


    /* trigger solution */

    maskEnergy = 0;
    maskMult = 0;
    for(i=0; i<NCLSTR; i++)
    {
      if(clusters[i] >= cluster_threshold)
	  {
        maskEnergy |= (1<<i);
#ifdef DEBUG
        printf("htcchit: cluster[%d]: energy=%d\n",i,(uint16_t)clusters[i]);
#endif
	  }
      if(mult[i] >= mult_threshold)
	  {
        maskMult |= (1<<i);
#ifdef DEBUG
        printf("htcchit: cluster[%d]: mult=%d\n",i,(uint16_t)mult[i]);
#endif
	  }
    }
    mask = maskEnergy & maskMult;
#ifdef DEBUG
    cout<<"htcchit: maskEnergy="<<hex<<maskEnergy<<dec<<endl;
    cout<<"htcchit:   maskMult="<<hex<<maskMult<<dec<<endl;
    cout<<"htcchit:       mask="<<hex<<mask<<dec<<endl;
#endif

    cmask = 0;
#ifdef DEBUG
    cout<<"htcchit: CMASK BEFOR="<<hex<<cmask<<dec<<endl;
#endif
    for(int i=0; i<NCLSTR; i++)
    {
      if( (mask>>i)&0x1 )
	  {
        for(int j=0; j<4; j++)
	    {
          cmask(cl2d[i][j],cl2d[i][j]) = 1;
#ifdef DEBUG
          cout<<"FOUND CLUSTER "<<i<<" -> ADD BIT " << cl2d[i][j] <<" to CMASK" << endl;
#endif
	    }
	  }
    }
#ifdef DEBUG
    cout<<"htcchit: CMASK AFTER="<<hex<<cmask<<dec<<endl;
#endif

    output = dmask & cmask;


#endif /*SINGLES*/





#ifdef DEBUG
    cout<<endl;
    cout<<"htcchit:  dmask="<<hex<<dmask<<dec<<endl;
    cout<<"htcchit:  cmask="<<hex<<cmask<<dec<<endl;
    cout<<"htcchit: output="<<hex<<output<<dec<<endl<<endl;
#endif


    s_hit[jj].output = output;

  } /* NH_READS */


}
