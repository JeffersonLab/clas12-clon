//  epics_server.cc

// pv classes for creating a PCAS


// notes:

//   PCAS probably not thread safe so need myUpdate flags

//   creates attrPV's (on the fly) to handle r/w to (case insensitive) fields:
//       HIHI,HIGH,LOLO,LOW,HOPR,LOPR,DRVH,DRVL,ALRM,STAT,SEVR,PREC
//       (n.b. VAL maps to regular data pv)

//   write only allowed to following fields:
//       ALRM,HIHI,LOLO,HIGH,LOW,HOPR,LOPR,DRVH,DRVL

//   all alarm limits are integers, set ALRM to 0(1) to turn alarms off(on)

//   have to set EPICS_CAS_INTF_ADDR_LIST to limit server to single network interface


// to do:


//  ejw, 3-jul-2003



// for posix
#define _POSIX_SOURCE_ 1
#define __EXTENSIONS__


// for ca
#include <casdef.h>
#include <alarm.h>
#include <gdd.h>


// for epics_server
#include <epics_server.h>


// misc
#include <iostream.h>
#include <iomanip.h>
#include <time.h>
#include <string.h>
#include <stdio.h>

#define MIN(a,b)  ( (a) < (b) ? (a) : (b) )
#define MAX(a,b)  ( (a) > (b) ? (a) : (b) )

//  misc variables
static int debug = 0;
static char temp[4096];
static int epicsToLocalTime  = 20*(365*24*60*60) + 5*(24*60*60) - (60*60); //?daylight savings?


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

myPV::myPV(const char *name, aitEnum type, int size)
{
    myName  = strdup(name);
    myType  = type;
    if(size<=1)
	{
      myDimension = 0u;
      myBound = 1u;
	}
    else
	{
      myDimension = 1u;
      myBound = size;
	}

    myTime  = 0;

    myIValue = 0;
    myUIValue = 0;
    myDValue = 0.0;
    for(int i=0; i<NDIM; i++) myUIArray[i] = 0;

    myStat = epicsAlarmNone;
    mySevr = epicsSevNone;
    myMonitor = 0;
    myUpdate = 0;

    initFT();
	
    if(debug!=0) cout << "myPV constructor for " << myName << endl;
}
  

//---------------------------------------------------


void myPV::fillPV(int i)
{

  if(i!=myIValue)
  {
	myUpdate=1;
	myIValue=i;
	myTime = time(NULL)-epicsToLocalTime;
  }
}


//------------------------------------------------------------------


void myPV::fillPV(uint ui)
{

  if(ui!=myUIValue)
  {
	myUpdate=1;
	myUIValue=ui;
	myTime = time(NULL)-epicsToLocalTime;
  }
}


//------------------------------------------------------------------


void myPV::fillPV(double d)
{

  if(d!=myDValue)
  {
	  myUpdate=1;
	  myDValue=d;
      myTime = time(NULL)-epicsToLocalTime;
  }
}


//------------------------------------------------------------------

void myPV::fillPV(unsigned int *iarray)
{

  printf("fillPV: myBound=%d, array=%d %d %d\n",myBound,myUIArray[0],myUIArray[1],myUIArray[2]);
  /*if(iarray[0] != myUIArray[0])*/
  {
	myUpdate=1;
	for(int i=0; i<myBound; i++) myUIArray[i] = iarray[i];
	myTime = time(NULL)-epicsToLocalTime;
  }
}



//---------------------------------------------------


caStatus myPV::read(const casCtx &ctx, gdd &prototype)
{
  return(ft.read(*this, prototype));
}


//---------------------------------------------------


void myPV::initFT()
{
  if(ft_is_initialized!=0) return;
  ft_is_initialized=1;

  ft.installReadFunc("value",    	    &myPV::getVAL);

  /*sergey: for now
  ft.installReadFunc("status",   	    &myPV::getSTAT);
  ft.installReadFunc("severity", 	    &myPV::getSEVR);
  ft.installReadFunc("graphicHigh", 	    &myPV::getHOPR);
  ft.installReadFunc("graphicLow",  	    &myPV::getLOPR);
  ft.installReadFunc("controlHigh", 	    &myPV::getDRVH);
  ft.installReadFunc("controlLow",  	    &myPV::getDRVL);
  ft.installReadFunc("alarmHigh",   	    &myPV::getHIHI);
  ft.installReadFunc("alarmLow",    	    &myPV::getLOLO);
  ft.installReadFunc("alarmHighWarning",  &myPV::getHIGH);
  ft.installReadFunc("alarmLowWarning",   &myPV::getLOW);
  ft.installReadFunc("units",       	    &myPV::getUNITS);
  ft.installReadFunc("precision",   	    &myPV::getPREC);
  ft.installReadFunc("enums",       	    &myPV::getENUM);
  */

}


//--------------------------------------------------


aitEnum myPV::bestExternalType() const
{
  
  printf("aitEnum myPV::bestExternalType reached\n");
  printf("aitEnum myPV::bestExternalType reached\n");
  printf("aitEnum myPV::bestExternalType reached\n");
  cout << "myType = " << myType << endl;

  return(myType);
}


//---------------------------------------------------

gddAppFuncTableStatus myPV::getVAL(gdd &value)
{

  //cout  << endl << "dim " << value.dimension() << endl;
  //sleep(3);

  if(debug!=0) cout << "...myPV getVAL for " << myName << endl;

  if(myType==aitEnumInt32)
  {
    value.putConvert(myIValue);
  }
  else if (myType==aitEnumUint32)
  {
    if(myDimension == 0)
	{
      value.putConvert(myUIValue);
	}
    else
	{
	  printf("getVAL: dim=%d array=%d %d %d ...\n",myBound,myUIArray[0],myUIArray[1],myUIArray[2]);
      /*value.put((const aitUint32*)myUIArray);*/
      /*value.put(myUIArray);*/
      value.putRef(myUIArray);
	}
  }
  else if (myType==aitEnumFloat64)
  {
    value.putConvert(myDValue);
  }
  else
  {
    cerr << "Unknown ait type " << myType << endl;
    value.putConvert(0);
  }

  value.setStat(myStat);
  value.setSevr(mySevr);

  struct timespec t;
  t.tv_sec = myTime;
  t.tv_nsec=0;
  value.setTimeStamp(&t);

  return S_casApp_success;
}
  


//---------------------------------------------------


caStatus myPV::interestRegister() {
    if(debug!=0) cout << "...myPV interestRegister for " << myName << endl;
    myMonitor=1;
    return S_casApp_success;
}


//---------------------------------------------------


void myPV::interestDelete() {
    if(debug!=0) cout << "...myPV interestDelete for " << myName << endl;
    myMonitor=0;
}


//---------------------------------------------------


epicsShareFunc const char *myPV::getName() const {
    return(myName);
}
  

//---------------------------------------------------


void myPV::destroy() {
    if(debug!=0)cout << "myPV destroy for " << myName << endl;
}
    

//---------------------------------------------------


myPV::~myPV() {
    if(debug!=0)cout << "myPV destructor for " << myName << endl;
}







//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------



//  must declare all static vars outside of class definition to allocate storage
int myPV::ft_is_initialized=0;
gddAppFuncTable<myPV> myPV::ft;


//---------------------------------------------------------------------------


void setDebug(int val) {
  debug=val;
}


//---------------------------------------------------------------------------
